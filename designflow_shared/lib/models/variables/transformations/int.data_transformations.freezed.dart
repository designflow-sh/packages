// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'int.data_transformations.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

IntDataTransformations _$IntDataTransformationsFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'add':
      return _Add.fromJson(json);
    case 'subtract':
      return _Subtract.fromJson(json);
    case 'multiply':
      return _Multiply.fromJson(json);
    case 'divide':
      return _Divide.fromJson(json);
    case 'round':
      return _Round.fromJson(json);
    case 'toDouble':
      return _ToDouble.fromJson(json);
    case 'toString':
      return _ToString.fromJson(json);
    case 'toStringAsPrecision':
      return _ToStringAsPrecision.fromJson(json);
    case 'isEqualTo':
      return _IsEqualTo.fromJson(json);
    case 'isNotEqualTo':
      return _IsNotEqualTo.fromJson(json);
    case 'isGreaterThan':
      return _IsGreaterThan.fromJson(json);
    case 'isGreaterThanOrEqualTo':
      return _IsGreaterThanOrEqualTo.fromJson(json);
    case 'isLessThan':
      return _IsLessThan.fromJson(json);
    case 'isLessThanOrEqualTo':
      return _IsLessThanOrEqualTo.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'IntDataTransformations',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$IntDataTransformations {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this IntDataTransformations to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntDataTransformationsCopyWith<$Res> {
  factory $IntDataTransformationsCopyWith(IntDataTransformations value,
          $Res Function(IntDataTransformations) then) =
      _$IntDataTransformationsCopyWithImpl<$Res, IntDataTransformations>;
}

/// @nodoc
class _$IntDataTransformationsCopyWithImpl<$Res,
        $Val extends IntDataTransformations>
    implements $IntDataTransformationsCopyWith<$Res> {
  _$IntDataTransformationsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$AddImplCopyWith<$Res> {
  factory _$$AddImplCopyWith(_$AddImpl value, $Res Function(_$AddImpl) then) =
      __$$AddImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$AddImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$AddImpl>
    implements _$$AddImplCopyWith<$Res> {
  __$$AddImplCopyWithImpl(_$AddImpl _value, $Res Function(_$AddImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$AddImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AddImpl extends _Add {
  const _$AddImpl({required this.value, final String? $type})
      : $type = $type ?? 'add',
        super._();

  factory _$AddImpl.fromJson(Map<String, dynamic> json) =>
      _$$AddImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.add(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddImplCopyWith<_$AddImpl> get copyWith =>
      __$$AddImplCopyWithImpl<_$AddImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return add(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return add?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AddImplToJson(
      this,
    );
  }
}

abstract class _Add extends IntDataTransformations {
  const factory _Add({required final int value}) = _$AddImpl;
  const _Add._() : super._();

  factory _Add.fromJson(Map<String, dynamic> json) = _$AddImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddImplCopyWith<_$AddImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SubtractImplCopyWith<$Res> {
  factory _$$SubtractImplCopyWith(
          _$SubtractImpl value, $Res Function(_$SubtractImpl) then) =
      __$$SubtractImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$SubtractImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$SubtractImpl>
    implements _$$SubtractImplCopyWith<$Res> {
  __$$SubtractImplCopyWithImpl(
      _$SubtractImpl _value, $Res Function(_$SubtractImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$SubtractImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SubtractImpl extends _Subtract {
  const _$SubtractImpl({required this.value, final String? $type})
      : $type = $type ?? 'subtract',
        super._();

  factory _$SubtractImpl.fromJson(Map<String, dynamic> json) =>
      _$$SubtractImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.subtract(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubtractImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubtractImplCopyWith<_$SubtractImpl> get copyWith =>
      __$$SubtractImplCopyWithImpl<_$SubtractImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return subtract(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return subtract?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (subtract != null) {
      return subtract(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return subtract(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return subtract?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (subtract != null) {
      return subtract(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SubtractImplToJson(
      this,
    );
  }
}

abstract class _Subtract extends IntDataTransformations {
  const factory _Subtract({required final int value}) = _$SubtractImpl;
  const _Subtract._() : super._();

  factory _Subtract.fromJson(Map<String, dynamic> json) =
      _$SubtractImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubtractImplCopyWith<_$SubtractImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MultiplyImplCopyWith<$Res> {
  factory _$$MultiplyImplCopyWith(
          _$MultiplyImpl value, $Res Function(_$MultiplyImpl) then) =
      __$$MultiplyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$MultiplyImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$MultiplyImpl>
    implements _$$MultiplyImplCopyWith<$Res> {
  __$$MultiplyImplCopyWithImpl(
      _$MultiplyImpl _value, $Res Function(_$MultiplyImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$MultiplyImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MultiplyImpl extends _Multiply {
  const _$MultiplyImpl({required this.value, final String? $type})
      : $type = $type ?? 'multiply',
        super._();

  factory _$MultiplyImpl.fromJson(Map<String, dynamic> json) =>
      _$$MultiplyImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.multiply(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MultiplyImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MultiplyImplCopyWith<_$MultiplyImpl> get copyWith =>
      __$$MultiplyImplCopyWithImpl<_$MultiplyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return multiply(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return multiply?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (multiply != null) {
      return multiply(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return multiply(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return multiply?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (multiply != null) {
      return multiply(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MultiplyImplToJson(
      this,
    );
  }
}

abstract class _Multiply extends IntDataTransformations {
  const factory _Multiply({required final int value}) = _$MultiplyImpl;
  const _Multiply._() : super._();

  factory _Multiply.fromJson(Map<String, dynamic> json) =
      _$MultiplyImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MultiplyImplCopyWith<_$MultiplyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DivideImplCopyWith<$Res> {
  factory _$$DivideImplCopyWith(
          _$DivideImpl value, $Res Function(_$DivideImpl) then) =
      __$$DivideImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$DivideImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$DivideImpl>
    implements _$$DivideImplCopyWith<$Res> {
  __$$DivideImplCopyWithImpl(
      _$DivideImpl _value, $Res Function(_$DivideImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$DivideImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DivideImpl extends _Divide {
  const _$DivideImpl({required this.value, final String? $type})
      : $type = $type ?? 'divide',
        super._();

  factory _$DivideImpl.fromJson(Map<String, dynamic> json) =>
      _$$DivideImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.divide(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DivideImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DivideImplCopyWith<_$DivideImpl> get copyWith =>
      __$$DivideImplCopyWithImpl<_$DivideImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return divide(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return divide?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (divide != null) {
      return divide(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return divide(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return divide?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (divide != null) {
      return divide(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DivideImplToJson(
      this,
    );
  }
}

abstract class _Divide extends IntDataTransformations {
  const factory _Divide({required final int value}) = _$DivideImpl;
  const _Divide._() : super._();

  factory _Divide.fromJson(Map<String, dynamic> json) = _$DivideImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DivideImplCopyWith<_$DivideImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RoundImplCopyWith<$Res> {
  factory _$$RoundImplCopyWith(
          _$RoundImpl value, $Res Function(_$RoundImpl) then) =
      __$$RoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RoundImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$RoundImpl>
    implements _$$RoundImplCopyWith<$Res> {
  __$$RoundImplCopyWithImpl(
      _$RoundImpl _value, $Res Function(_$RoundImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$RoundImpl extends _Round {
  const _$RoundImpl({final String? $type})
      : $type = $type ?? 'round',
        super._();

  factory _$RoundImpl.fromJson(Map<String, dynamic> json) =>
      _$$RoundImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.round()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RoundImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return round();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return round?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (round != null) {
      return round();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return round(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return round?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (round != null) {
      return round(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RoundImplToJson(
      this,
    );
  }
}

abstract class _Round extends IntDataTransformations {
  const factory _Round() = _$RoundImpl;
  const _Round._() : super._();

  factory _Round.fromJson(Map<String, dynamic> json) = _$RoundImpl.fromJson;
}

/// @nodoc
abstract class _$$ToDoubleImplCopyWith<$Res> {
  factory _$$ToDoubleImplCopyWith(
          _$ToDoubleImpl value, $Res Function(_$ToDoubleImpl) then) =
      __$$ToDoubleImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToDoubleImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$ToDoubleImpl>
    implements _$$ToDoubleImplCopyWith<$Res> {
  __$$ToDoubleImplCopyWithImpl(
      _$ToDoubleImpl _value, $Res Function(_$ToDoubleImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$ToDoubleImpl extends _ToDouble {
  const _$ToDoubleImpl({final String? $type})
      : $type = $type ?? 'toDouble',
        super._();

  factory _$ToDoubleImpl.fromJson(Map<String, dynamic> json) =>
      _$$ToDoubleImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.toDouble()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToDoubleImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return toDouble();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return toDouble?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (toDouble != null) {
      return toDouble();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return toDouble(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return toDouble?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (toDouble != null) {
      return toDouble(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ToDoubleImplToJson(
      this,
    );
  }
}

abstract class _ToDouble extends IntDataTransformations {
  const factory _ToDouble() = _$ToDoubleImpl;
  const _ToDouble._() : super._();

  factory _ToDouble.fromJson(Map<String, dynamic> json) =
      _$ToDoubleImpl.fromJson;
}

/// @nodoc
abstract class _$$ToStringImplCopyWith<$Res> {
  factory _$$ToStringImplCopyWith(
          _$ToStringImpl value, $Res Function(_$ToStringImpl) then) =
      __$$ToStringImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToStringImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$ToStringImpl>
    implements _$$ToStringImplCopyWith<$Res> {
  __$$ToStringImplCopyWithImpl(
      _$ToStringImpl _value, $Res Function(_$ToStringImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$ToStringImpl extends _ToString {
  const _$ToStringImpl({final String? $type})
      : $type = $type ?? 'toString',
        super._();

  factory _$ToStringImpl.fromJson(Map<String, dynamic> json) =>
      _$$ToStringImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.toString()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToStringImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return toString();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return toString?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (toString != null) {
      return toString();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return toString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return toString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (toString != null) {
      return toString(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ToStringImplToJson(
      this,
    );
  }
}

abstract class _ToString extends IntDataTransformations {
  const factory _ToString() = _$ToStringImpl;
  const _ToString._() : super._();

  factory _ToString.fromJson(Map<String, dynamic> json) =
      _$ToStringImpl.fromJson;
}

/// @nodoc
abstract class _$$ToStringAsPrecisionImplCopyWith<$Res> {
  factory _$$ToStringAsPrecisionImplCopyWith(_$ToStringAsPrecisionImpl value,
          $Res Function(_$ToStringAsPrecisionImpl) then) =
      __$$ToStringAsPrecisionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int precision});
}

/// @nodoc
class __$$ToStringAsPrecisionImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res,
        _$ToStringAsPrecisionImpl>
    implements _$$ToStringAsPrecisionImplCopyWith<$Res> {
  __$$ToStringAsPrecisionImplCopyWithImpl(_$ToStringAsPrecisionImpl _value,
      $Res Function(_$ToStringAsPrecisionImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? precision = null,
  }) {
    return _then(_$ToStringAsPrecisionImpl(
      precision: null == precision
          ? _value.precision
          : precision // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ToStringAsPrecisionImpl extends _ToStringAsPrecision {
  const _$ToStringAsPrecisionImpl(
      {required this.precision, final String? $type})
      : $type = $type ?? 'toStringAsPrecision',
        super._();

  factory _$ToStringAsPrecisionImpl.fromJson(Map<String, dynamic> json) =>
      _$$ToStringAsPrecisionImplFromJson(json);

  @override
  final int precision;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.toStringAsPrecision(precision: $precision)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ToStringAsPrecisionImpl &&
            (identical(other.precision, precision) ||
                other.precision == precision));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, precision);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ToStringAsPrecisionImplCopyWith<_$ToStringAsPrecisionImpl> get copyWith =>
      __$$ToStringAsPrecisionImplCopyWithImpl<_$ToStringAsPrecisionImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return toStringAsPrecision(precision);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return toStringAsPrecision?.call(precision);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (toStringAsPrecision != null) {
      return toStringAsPrecision(precision);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return toStringAsPrecision(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return toStringAsPrecision?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (toStringAsPrecision != null) {
      return toStringAsPrecision(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ToStringAsPrecisionImplToJson(
      this,
    );
  }
}

abstract class _ToStringAsPrecision extends IntDataTransformations {
  const factory _ToStringAsPrecision({required final int precision}) =
      _$ToStringAsPrecisionImpl;
  const _ToStringAsPrecision._() : super._();

  factory _ToStringAsPrecision.fromJson(Map<String, dynamic> json) =
      _$ToStringAsPrecisionImpl.fromJson;

  int get precision;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ToStringAsPrecisionImplCopyWith<_$ToStringAsPrecisionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IsEqualToImplCopyWith<$Res> {
  factory _$$IsEqualToImplCopyWith(
          _$IsEqualToImpl value, $Res Function(_$IsEqualToImpl) then) =
      __$$IsEqualToImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$IsEqualToImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$IsEqualToImpl>
    implements _$$IsEqualToImplCopyWith<$Res> {
  __$$IsEqualToImplCopyWithImpl(
      _$IsEqualToImpl _value, $Res Function(_$IsEqualToImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$IsEqualToImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IsEqualToImpl extends _IsEqualTo {
  const _$IsEqualToImpl({required this.value, final String? $type})
      : $type = $type ?? 'isEqualTo',
        super._();

  factory _$IsEqualToImpl.fromJson(Map<String, dynamic> json) =>
      _$$IsEqualToImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.isEqualTo(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IsEqualToImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IsEqualToImplCopyWith<_$IsEqualToImpl> get copyWith =>
      __$$IsEqualToImplCopyWithImpl<_$IsEqualToImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return isEqualTo(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return isEqualTo?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isEqualTo != null) {
      return isEqualTo(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return isEqualTo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return isEqualTo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isEqualTo != null) {
      return isEqualTo(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IsEqualToImplToJson(
      this,
    );
  }
}

abstract class _IsEqualTo extends IntDataTransformations {
  const factory _IsEqualTo({required final int value}) = _$IsEqualToImpl;
  const _IsEqualTo._() : super._();

  factory _IsEqualTo.fromJson(Map<String, dynamic> json) =
      _$IsEqualToImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IsEqualToImplCopyWith<_$IsEqualToImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IsNotEqualToImplCopyWith<$Res> {
  factory _$$IsNotEqualToImplCopyWith(
          _$IsNotEqualToImpl value, $Res Function(_$IsNotEqualToImpl) then) =
      __$$IsNotEqualToImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$IsNotEqualToImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$IsNotEqualToImpl>
    implements _$$IsNotEqualToImplCopyWith<$Res> {
  __$$IsNotEqualToImplCopyWithImpl(
      _$IsNotEqualToImpl _value, $Res Function(_$IsNotEqualToImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$IsNotEqualToImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IsNotEqualToImpl extends _IsNotEqualTo {
  const _$IsNotEqualToImpl({required this.value, final String? $type})
      : $type = $type ?? 'isNotEqualTo',
        super._();

  factory _$IsNotEqualToImpl.fromJson(Map<String, dynamic> json) =>
      _$$IsNotEqualToImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.isNotEqualTo(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IsNotEqualToImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IsNotEqualToImplCopyWith<_$IsNotEqualToImpl> get copyWith =>
      __$$IsNotEqualToImplCopyWithImpl<_$IsNotEqualToImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return isNotEqualTo(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return isNotEqualTo?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isNotEqualTo != null) {
      return isNotEqualTo(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return isNotEqualTo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return isNotEqualTo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isNotEqualTo != null) {
      return isNotEqualTo(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IsNotEqualToImplToJson(
      this,
    );
  }
}

abstract class _IsNotEqualTo extends IntDataTransformations {
  const factory _IsNotEqualTo({required final int value}) = _$IsNotEqualToImpl;
  const _IsNotEqualTo._() : super._();

  factory _IsNotEqualTo.fromJson(Map<String, dynamic> json) =
      _$IsNotEqualToImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IsNotEqualToImplCopyWith<_$IsNotEqualToImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IsGreaterThanImplCopyWith<$Res> {
  factory _$$IsGreaterThanImplCopyWith(
          _$IsGreaterThanImpl value, $Res Function(_$IsGreaterThanImpl) then) =
      __$$IsGreaterThanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$IsGreaterThanImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$IsGreaterThanImpl>
    implements _$$IsGreaterThanImplCopyWith<$Res> {
  __$$IsGreaterThanImplCopyWithImpl(
      _$IsGreaterThanImpl _value, $Res Function(_$IsGreaterThanImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$IsGreaterThanImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IsGreaterThanImpl extends _IsGreaterThan {
  const _$IsGreaterThanImpl({required this.value, final String? $type})
      : $type = $type ?? 'isGreaterThan',
        super._();

  factory _$IsGreaterThanImpl.fromJson(Map<String, dynamic> json) =>
      _$$IsGreaterThanImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.isGreaterThan(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IsGreaterThanImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IsGreaterThanImplCopyWith<_$IsGreaterThanImpl> get copyWith =>
      __$$IsGreaterThanImplCopyWithImpl<_$IsGreaterThanImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return isGreaterThan(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return isGreaterThan?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isGreaterThan != null) {
      return isGreaterThan(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return isGreaterThan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return isGreaterThan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isGreaterThan != null) {
      return isGreaterThan(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IsGreaterThanImplToJson(
      this,
    );
  }
}

abstract class _IsGreaterThan extends IntDataTransformations {
  const factory _IsGreaterThan({required final int value}) =
      _$IsGreaterThanImpl;
  const _IsGreaterThan._() : super._();

  factory _IsGreaterThan.fromJson(Map<String, dynamic> json) =
      _$IsGreaterThanImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IsGreaterThanImplCopyWith<_$IsGreaterThanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IsGreaterThanOrEqualToImplCopyWith<$Res> {
  factory _$$IsGreaterThanOrEqualToImplCopyWith(
          _$IsGreaterThanOrEqualToImpl value,
          $Res Function(_$IsGreaterThanOrEqualToImpl) then) =
      __$$IsGreaterThanOrEqualToImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$IsGreaterThanOrEqualToImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res,
        _$IsGreaterThanOrEqualToImpl>
    implements _$$IsGreaterThanOrEqualToImplCopyWith<$Res> {
  __$$IsGreaterThanOrEqualToImplCopyWithImpl(
      _$IsGreaterThanOrEqualToImpl _value,
      $Res Function(_$IsGreaterThanOrEqualToImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$IsGreaterThanOrEqualToImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IsGreaterThanOrEqualToImpl extends _IsGreaterThanOrEqualTo {
  const _$IsGreaterThanOrEqualToImpl({required this.value, final String? $type})
      : $type = $type ?? 'isGreaterThanOrEqualTo',
        super._();

  factory _$IsGreaterThanOrEqualToImpl.fromJson(Map<String, dynamic> json) =>
      _$$IsGreaterThanOrEqualToImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.isGreaterThanOrEqualTo(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IsGreaterThanOrEqualToImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IsGreaterThanOrEqualToImplCopyWith<_$IsGreaterThanOrEqualToImpl>
      get copyWith => __$$IsGreaterThanOrEqualToImplCopyWithImpl<
          _$IsGreaterThanOrEqualToImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return isGreaterThanOrEqualTo(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return isGreaterThanOrEqualTo?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isGreaterThanOrEqualTo != null) {
      return isGreaterThanOrEqualTo(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return isGreaterThanOrEqualTo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return isGreaterThanOrEqualTo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isGreaterThanOrEqualTo != null) {
      return isGreaterThanOrEqualTo(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IsGreaterThanOrEqualToImplToJson(
      this,
    );
  }
}

abstract class _IsGreaterThanOrEqualTo extends IntDataTransformations {
  const factory _IsGreaterThanOrEqualTo({required final int value}) =
      _$IsGreaterThanOrEqualToImpl;
  const _IsGreaterThanOrEqualTo._() : super._();

  factory _IsGreaterThanOrEqualTo.fromJson(Map<String, dynamic> json) =
      _$IsGreaterThanOrEqualToImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IsGreaterThanOrEqualToImplCopyWith<_$IsGreaterThanOrEqualToImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IsLessThanImplCopyWith<$Res> {
  factory _$$IsLessThanImplCopyWith(
          _$IsLessThanImpl value, $Res Function(_$IsLessThanImpl) then) =
      __$$IsLessThanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$IsLessThanImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res, _$IsLessThanImpl>
    implements _$$IsLessThanImplCopyWith<$Res> {
  __$$IsLessThanImplCopyWithImpl(
      _$IsLessThanImpl _value, $Res Function(_$IsLessThanImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$IsLessThanImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IsLessThanImpl extends _IsLessThan {
  const _$IsLessThanImpl({required this.value, final String? $type})
      : $type = $type ?? 'isLessThan',
        super._();

  factory _$IsLessThanImpl.fromJson(Map<String, dynamic> json) =>
      _$$IsLessThanImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.isLessThan(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IsLessThanImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IsLessThanImplCopyWith<_$IsLessThanImpl> get copyWith =>
      __$$IsLessThanImplCopyWithImpl<_$IsLessThanImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return isLessThan(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return isLessThan?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isLessThan != null) {
      return isLessThan(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return isLessThan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return isLessThan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isLessThan != null) {
      return isLessThan(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IsLessThanImplToJson(
      this,
    );
  }
}

abstract class _IsLessThan extends IntDataTransformations {
  const factory _IsLessThan({required final int value}) = _$IsLessThanImpl;
  const _IsLessThan._() : super._();

  factory _IsLessThan.fromJson(Map<String, dynamic> json) =
      _$IsLessThanImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IsLessThanImplCopyWith<_$IsLessThanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IsLessThanOrEqualToImplCopyWith<$Res> {
  factory _$$IsLessThanOrEqualToImplCopyWith(_$IsLessThanOrEqualToImpl value,
          $Res Function(_$IsLessThanOrEqualToImpl) then) =
      __$$IsLessThanOrEqualToImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$IsLessThanOrEqualToImplCopyWithImpl<$Res>
    extends _$IntDataTransformationsCopyWithImpl<$Res,
        _$IsLessThanOrEqualToImpl>
    implements _$$IsLessThanOrEqualToImplCopyWith<$Res> {
  __$$IsLessThanOrEqualToImplCopyWithImpl(_$IsLessThanOrEqualToImpl _value,
      $Res Function(_$IsLessThanOrEqualToImpl) _then)
      : super(_value, _then);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$IsLessThanOrEqualToImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IsLessThanOrEqualToImpl extends _IsLessThanOrEqualTo {
  const _$IsLessThanOrEqualToImpl({required this.value, final String? $type})
      : $type = $type ?? 'isLessThanOrEqualTo',
        super._();

  factory _$IsLessThanOrEqualToImpl.fromJson(Map<String, dynamic> json) =>
      _$$IsLessThanOrEqualToImplFromJson(json);

  @override
  final int value;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'IntDataTransformations.isLessThanOrEqualTo(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IsLessThanOrEqualToImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IsLessThanOrEqualToImplCopyWith<_$IsLessThanOrEqualToImpl> get copyWith =>
      __$$IsLessThanOrEqualToImplCopyWithImpl<_$IsLessThanOrEqualToImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int value) add,
    required TResult Function(int value) subtract,
    required TResult Function(int value) multiply,
    required TResult Function(int value) divide,
    required TResult Function() round,
    required TResult Function() toDouble,
    required TResult Function() toString,
    required TResult Function(int precision) toStringAsPrecision,
    required TResult Function(int value) isEqualTo,
    required TResult Function(int value) isNotEqualTo,
    required TResult Function(int value) isGreaterThan,
    required TResult Function(int value) isGreaterThanOrEqualTo,
    required TResult Function(int value) isLessThan,
    required TResult Function(int value) isLessThanOrEqualTo,
  }) {
    return isLessThanOrEqualTo(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int value)? add,
    TResult? Function(int value)? subtract,
    TResult? Function(int value)? multiply,
    TResult? Function(int value)? divide,
    TResult? Function()? round,
    TResult? Function()? toDouble,
    TResult? Function()? toString,
    TResult? Function(int precision)? toStringAsPrecision,
    TResult? Function(int value)? isEqualTo,
    TResult? Function(int value)? isNotEqualTo,
    TResult? Function(int value)? isGreaterThan,
    TResult? Function(int value)? isGreaterThanOrEqualTo,
    TResult? Function(int value)? isLessThan,
    TResult? Function(int value)? isLessThanOrEqualTo,
  }) {
    return isLessThanOrEqualTo?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int value)? add,
    TResult Function(int value)? subtract,
    TResult Function(int value)? multiply,
    TResult Function(int value)? divide,
    TResult Function()? round,
    TResult Function()? toDouble,
    TResult Function()? toString,
    TResult Function(int precision)? toStringAsPrecision,
    TResult Function(int value)? isEqualTo,
    TResult Function(int value)? isNotEqualTo,
    TResult Function(int value)? isGreaterThan,
    TResult Function(int value)? isGreaterThanOrEqualTo,
    TResult Function(int value)? isLessThan,
    TResult Function(int value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isLessThanOrEqualTo != null) {
      return isLessThanOrEqualTo(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Add value) add,
    required TResult Function(_Subtract value) subtract,
    required TResult Function(_Multiply value) multiply,
    required TResult Function(_Divide value) divide,
    required TResult Function(_Round value) round,
    required TResult Function(_ToDouble value) toDouble,
    required TResult Function(_ToString value) toString,
    required TResult Function(_ToStringAsPrecision value) toStringAsPrecision,
    required TResult Function(_IsEqualTo value) isEqualTo,
    required TResult Function(_IsNotEqualTo value) isNotEqualTo,
    required TResult Function(_IsGreaterThan value) isGreaterThan,
    required TResult Function(_IsGreaterThanOrEqualTo value)
        isGreaterThanOrEqualTo,
    required TResult Function(_IsLessThan value) isLessThan,
    required TResult Function(_IsLessThanOrEqualTo value) isLessThanOrEqualTo,
  }) {
    return isLessThanOrEqualTo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Add value)? add,
    TResult? Function(_Subtract value)? subtract,
    TResult? Function(_Multiply value)? multiply,
    TResult? Function(_Divide value)? divide,
    TResult? Function(_Round value)? round,
    TResult? Function(_ToDouble value)? toDouble,
    TResult? Function(_ToString value)? toString,
    TResult? Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult? Function(_IsEqualTo value)? isEqualTo,
    TResult? Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult? Function(_IsGreaterThan value)? isGreaterThan,
    TResult? Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult? Function(_IsLessThan value)? isLessThan,
    TResult? Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
  }) {
    return isLessThanOrEqualTo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Add value)? add,
    TResult Function(_Subtract value)? subtract,
    TResult Function(_Multiply value)? multiply,
    TResult Function(_Divide value)? divide,
    TResult Function(_Round value)? round,
    TResult Function(_ToDouble value)? toDouble,
    TResult Function(_ToString value)? toString,
    TResult Function(_ToStringAsPrecision value)? toStringAsPrecision,
    TResult Function(_IsEqualTo value)? isEqualTo,
    TResult Function(_IsNotEqualTo value)? isNotEqualTo,
    TResult Function(_IsGreaterThan value)? isGreaterThan,
    TResult Function(_IsGreaterThanOrEqualTo value)? isGreaterThanOrEqualTo,
    TResult Function(_IsLessThan value)? isLessThan,
    TResult Function(_IsLessThanOrEqualTo value)? isLessThanOrEqualTo,
    required TResult orElse(),
  }) {
    if (isLessThanOrEqualTo != null) {
      return isLessThanOrEqualTo(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$IsLessThanOrEqualToImplToJson(
      this,
    );
  }
}

abstract class _IsLessThanOrEqualTo extends IntDataTransformations {
  const factory _IsLessThanOrEqualTo({required final int value}) =
      _$IsLessThanOrEqualToImpl;
  const _IsLessThanOrEqualTo._() : super._();

  factory _IsLessThanOrEqualTo.fromJson(Map<String, dynamic> json) =
      _$IsLessThanOrEqualToImpl.fromJson;

  int get value;

  /// Create a copy of IntDataTransformations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IsLessThanOrEqualToImplCopyWith<_$IsLessThanOrEqualToImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
